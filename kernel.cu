#include "kernel.cuh"
using namespace std;


void cudaResultCheck(cudaError_t result,char* fileName, char* functionName, int lineNum)
{
	if (result != cudaSuccess)
	{
		cudaError_t error = cudaGetLastError();
		printf("*CUDA error in file %s, \n*function %s, \n*line %d: %s\n",fileName, functionName, lineNum, cudaGetErrorString(error));
	}
	return;
}

void cudaInit(vector<int>& iGPU,
	vector<void*>& stream)
{
	//cudaError_t result = cudaSetDevice(1);
	int deviceNum;
	cudaGetDeviceCount(&deviceNum);
	for (int i = 0; i < deviceNum; i++)
	{
		iGPU.push_back(i);
		for (int j = 0; j < NUM_STREAM_PER_DEVICE; j++)
		{
			cudaStream_t* newStream = new cudaStream_t;
			stream.push_back((void*)newStream);
		}
	}
	//cudaError_t result = cudaSetDevice(0);
	//cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);
	return;
}

void cudaEndUp(vector<int>& iGPU,
	vector<void*>& stream)
{
	
	for (int j = 0; j < stream.size(); j++)
	{
		delete stream[j];
	}	

	/*关于cudaDeviceReset的使用还需要再研究一下 与current device和current process都有关
	for (int i = 0; i < iGPU.size(); i++)
	{
		cudaDeviceReset();
	}
	*/
}

void devMalloc(int** devData, int dataSize)
{
	cudaError_t result = cudaMalloc((void**)devData, dataSize);
	cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);
	return;
}

void hostRegister(int* imgData, int dataSizeByte)
{
	cudaError_t result = cudaHostRegister(imgData,dataSizeByte,cudaHostRegisterDefault);
	cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);
	return;
}

void hostFree(int* imgData)
{
	cudaError_t result =  cudaHostUnregister(imgData);
	cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);
	return;
}


void substract(
	vector<void*>& stream,	//这里使用vector，要在头文件中包括进来
	vector<int>& iGPU,
	int* imgData,	//imgData当中存储了IMAGE_TOTAL_NUM张照片，但是会在多GPU，多stream当中，再次拆分一次
	int idim,		//reMask里这个值传入的是_para.size,是图像一条边的长度。
	int nImg,		//交给substract函数处理的图片总数，在function.cpp当中也是一个batch，一般大小为IMAGE_BATCH
	int nGPU
)
{
	//LOG(INFO) << "Subtract begin.";

	//每个GPU对应一个int*
	//已写delete空间代码
	//这一段是不需要的 在reMask当中有这么一段是为了给每台GPU一个mask以方便计算
	//int** devSubstract = new int*[nGPU];

	//一个image的像素点数量
	size_t imgSizeRL = idim * idim;

	//定义stream的总数
	int nStream = nGPU * NUM_STREAM_PER_DEVICE;

	//这个数组当中存储的是指针，每个指针都指向一整段空间地址（能存储BATCH_SIZE张image）
	int** dev_image_buf = new int*[nStream];

	int threadInBlock = (idim > THREAD_PER_BLOCK) ? THREAD_PER_BLOCK : idim;

	//base Stream
	int baseS;

	int nImgBatch = 0;
	int smidx = 0;

	//为每台GPU上的每个流分配空间，分配BATCH_SIZE张照片的图片
	for (int n = 0; n < nGPU; n++)
	{
		baseS = n * NUM_STREAM_PER_DEVICE;
		cudaSetDevice(iGPU[n]);

		for (int i = 0; i < NUM_STREAM_PER_DEVICE; i++)
		{
			cudaError_t result = cudaMalloc(&dev_image_buf[i + baseS], BATCH_SIZE * imgSizeRL * sizeof(int));
			cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);
		}
	}

	//LOG(INFO) << "alloc memory done, begin to calculate...";

	for (int i = 0; i < nImg;)
	{

		//多GPU并行 不过本台机器只有一台GPU
		for (int n = 0; n < nGPU; n++)
		{
			//设定device并且开辟空间，检查错误
			cudaSetDevice(iGPU[n]);
			cudaError_t result = cudaMalloc((void**)&devSubstract[n], imgSizeRL * sizeof(int));
			cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);

			//对于当前GPU的base stream
			baseS = n * NUM_STREAM_PER_DEVICE;
			nImgBatch = (i + BATCH_SIZE < nImg) ? BATCH_SIZE : (nImg - i);
			
			//将数据从host拷贝到device上
			//异步拷贝
			result = cudaMemcpyAsync(dev_image_buf[smidx + baseS],
				imgData + i * imgSizeRL,	//注意指针的偏移量，不用去加sizeof(int)
				nImgBatch * imgSizeRL * sizeof(int),
				cudaMemcpyHostToDevice,
				*((cudaStream_t*)(stream[smidx + baseS]))	//由于stream当中的存储类型为void*，这里需要先转换指针类型再解引用。
			);
			cudaResultCheck(result, __FILE__, __FUNCTION__, __LINE__);

			for (int r = 0; r < nImgBatch; n++)
			{
				//计算偏移量
				long long shiftRL = (long long)r * imgSizeRL;
				//一次只处理一张照片,处理完了之后将数据直接写回dev_image_buf当中
				kernel_substract <<<
					idim,
					threadInBlock,
					0,
					*((cudaStream_t*)stream[smidx + baseS])>>>(
						dev_image_buf[smidx + baseS],	//这里保存了从imgData里面拷贝过来的数据，做了修改之后记得写回去
						r,								//处理这个batch当中的第r张照片
						idim,							//一张照片的长度/宽度
						imgSizeRL						//一张照片在实空间当中所占据的像素点数
						);
			}

			//一个batch里所有的照片处理完毕之后，应该写回imgData当中
			//TODO


		}

		smidx = (smidx + 1) % NUM_STREAM_PER_DEVICE;
	}
	//delete[] devSubstract;
}